这道题是一个经典的广度优先搜索的模板题，对于对BFS不熟悉的人，这里先给出BFS的基本思想：
1.对于初始状态入队，设置初始状态为已访问
2.如果队列不为空时，出队队头元素，否则跳到第5步
3.检查出队的元素是否为最终解，如果是则跳到第5步。
4.对于出队的元素，检查所有相邻状态，如果有效并且未访问，则将所有有效的相邻状态进行入队，并且设置这些状态为已访问，然后跳到第2步重复执行
5.检查最后出队的元素是否为最终解，如果是输出结果，否则说明无解

或者是一个更加一般的描述：

对于给定的图G=(V,E),BFS从图中的一个节点s开始搜索此图,在搜索的过程中动态创建一颗BFS树,BFS树有如下性质:
1.BFS树包含能源点s到达的所有图中节点
2.对于BFS树中的一个节点u,u在BFS树中到s点的简单路径长度即为图中s点到u点的最短路径长度(这道题的关键所在)

对于BFS的搜索过程:
0.将源点标记为已搜索
1.先发现所有与已搜索相邻的节点,记录所有这些相邻节点相邻的节点
2.对于所有已发现的点,探索其相邻的所有未搜索节点,一旦一个节点的所有相邻边均被探索完,将其标记为已搜索
4.重复2.3.直到无节点可搜

广度优先搜索算法的关键是要搞清楚求解过程中每一步的相邻状态有哪些，
每个状态需要记录什么信息，在搜索过程中如何标记这些状态为已访问。

在本题中，相邻状态为当前所在楼层通过按向上或向下按钮所能到达的楼
层，每个状态要记录的信息包括楼层编号和按按钮的次数。

对于此题,有一个具体化的思路:
1.初始楼层先入队,将初始条件标明为已搜索
对应代码:
c.index = a;
c.total = 0;
q.push(c);
check[1] = true;

2.出队队头楼层,若队头楼层即为目标楼层,直接输出并结束算法.否则探索队头楼层可通过上下到达的楼层,并将其入队
对应代码:
while(!q.empty()){
    d = q.front();
    q.pop();
    if(d.index == b) break;
    i = d.index + t[d.index];
    if(i <= n && !check[i]) {
        c.index = i;
        c.total = d.total + 1;
        q.push(c);
        check[i] = true;
    }
    i = d.index - t[d.index];
    if(i >= 1 && !check[i]) {
        c.index = i;
        c.total = d.total + 1;
        q.push(c);
        check[i] = true;
    }
}

3.重复第二步,若第二步已经到达终止条件且最后出队的楼层不是目标楼层,则无解,输出-1,否则输出最后出队的楼层
对应代码:
if(d.index == b) cout << d.total;
else cout << -1;
